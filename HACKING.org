#+TITLE: HACKING lsp-mcp
#+AUTHOR: Codex Agent
#+DATE: 2025-11-16
#+FILETAGS: :guide:hacking:mcp:lsp:
#+OPTIONS: toc:2
#+SUBTITLE: Practical notebook for contributors building and debugging the MCP↔LSP bridge inside this repo.
#+DESCRIPTION: Hands-on notes for day-to-day development, CI readiness, schema regeneration, and containerized deployment scenarios, emphasizing reproducible commands and stable behaviors.
#+KEYWORDS: mcp lsp typescript cli org-guide hacking onboarding debugging testing docker configs
#+CATEGORY: development-handbook cross-team
#+STARTUP: showall logdrawer
#+ABSTRACT: Captures architecture decisions, runtime data flow, environment setup steps, extension hooks, and troubleshooting heuristics so future agents can audit MCP tool definitions, reason about JSON-RPC conversations, and evolve LSP coverage without destabilizing the CLI.
#+NOTES: Document assumes familiarity with Yarn, ts-node, uvx, @wong2/mcp-cli, Docker networking, and cross-platform signal handling for clean shutdowns. Adjust instructions if CLI entrypoint changes.

* Repository Fact Sheet
:PROPERTIES:
:Primary-Language: TypeScript (Node 20+ runtime assumed)
:Entry-Point: src/index.ts → dist/index.js
:CLI: lsp-mcp
:Protocols: Model Context Protocol (tools) ↔ Language Server Protocol
:END:
- Source lives under [[file:src/][=src/=]] with generated protocol metadata at [[file:src/3rdparty/metaModel.ts][=src/3rdparty/metaModel.ts=]] and schemas inside [[file:src/resources/][=src/resources/=]].
- Development configs are in [[file:dev/][=dev/=]] while compiled JS and copied assets land in [[file:dist/][=dist/=]] after =yarn build=.

* Component Topology
- [[file:src/app.ts::16][=App=]] orchestrates startup: it materializes [[file:src/tool-manager.ts::11][=ToolManager=]], wires [[file:src/lsp-manager.ts::3][=LspManager=]] with [[file:src/lsp.ts::21][=LspClientImpl=]] instances, exposes MCP handlers, and caches allowed LSP methods from [[file:src/lsp-methods.ts::99][=getLspMethods=]].
- [[file:src/tool-manager.ts::11][=ToolManager=]] is a thin registry that enforces JSON-schema-described inputs and funnels invocations to async handlers.
- [[file:src/lsp.ts::21][=LspClientImpl=]] wraps a spawned LSP process, manages JSON-RPC wiring, and provides =sendRequest= / =sendNotification= primitives with lazy startup semantics.
- [[file:src/lsp-manager.ts::3][=LspManager=]] bridges workspaces, languages, and extensions to concrete clients, exposing heuristics for “best” LSP selection when a caller omits the ID.
- [[file:src/lsp-methods.ts][=lsp-methods.ts=]] dereferences the upstream JSON Schema into MCP tools, trimming invariants and ensuring referenced files are opened before dispatch.
- [[file:src/config.ts][=config.ts=]] validates user-supplied =lsps=, optional method allow-lists, and workspace roots via Zod.

* Lifecycle & Data Flow
1. **Config ingestion** – CLI flags or =--config= blobs are parsed in [[file:src/index.ts::7][=src/index.ts=]], producing a [[file:src/config.ts::5][=Config=]] object with all LSP processes and workspace overrides.
2. **LSP instantiation** – [[file:src/app.ts::249][=App.buildLsps=]] creates [[file:src/lsp.ts::21][=LspClientImpl=]] objects per config entry, deferring child process execution until the first RPC request.
3. **Tool registration** – [[file:src/app.ts::73][Helpers]] register debugging aids ([[file:src/app.ts::75][=lsp_info=]], [[file:src/app.ts::102][=file_contents_to_uri=]]) plus one MCP tool per allowed LSP request; with multiple LSPs an optional =lsp= enum is added automatically.
4. **Runtime dispatch** – MCP =CallTool= requests resolve to a handler that guesses the proper LSP (explicit ID, language hint, URI extension, or default) and relays the call via [[file:src/app.ts::150][=lspMethodHandler=]], opening referenced files beforehand.
5. **Shutdown** – Signals trigger [[file:src/app.ts::207][=App.dispose()=]], disposing each =LspClient= and closing the MCP transport.

* Configuration Surfaces
- Example multi-LSP setup: see [[file:dev/dev.config.json][=dev/dev.config.json=]], mixing =typescript-language-server= (npx) and =pylsp= (uvx). Each entry defines =id=, =extensions=, =languages=, =command=, and =args=; keep IDs lowercase for simpler lookup.
- =methods= accepts an array of raw LSP method strings surfaced from [[file:src/lsp-methods.ts::99][=getLspMethods=]]. Skip it for full coverage, but large schemas can overwhelm lightweight MCP clients, so filter when iterating.
- =workspace= defaults to =/=; override with a host or container path when the LSP needs file access. =mem://= URIs remain viable for synthetic buffers via [[file:src/app.ts::102][=file_contents_to_uri=]].
- When packaging for Docker, check these configs into the image or wire env templating externally; the loader does not yet substitute variables.

* Development Environment
- Install dependencies once with =yarn=; =corepack enable= keeps Yarn v4 pinning consistent.
- Day-to-day loops typically use =yarn dev --config dev/dev.config.json --verbose= for rich logging, or =yarn dev --lsp "<command>" --methods textDocument/documentSymbol= for targeted tests.
- Use =yarn mcp-cli:simple= or =:config= to run the sample =@wong2/mcp-cli= scenarios in [[file:dev/mcp-cli/][=dev/mcp-cli/=]]; they catch schema regressions early.
- Formatting and linting live behind =yarn format= and =yarn lint=; resolve issues locally to keep diffs behavioral.

* Extending Capabilities
- **Adding an LSP**: append a new object to =lsps=, include language identifiers plus extensions, and point the =command= to something available inside Docker or local shells. Restart dev servers so [[file:src/lsp-manager.ts::3][=LspManager=]] rebuilds its caches.
- **Whitelisting methods**: When upstream schemas lag, update [[file:src/resources/generated.protocol.schema.json][=src/resources/generated.protocol.schema.json=]] plus [[file:src/3rdparty/metaModel.ts][=src/3rdparty/metaModel.ts=]], cite the source in your PR, and rerun =yarn build= to propagate assets.
- **Custom tools**: Register additional =Tool=s inside [[file:src/app.ts::73][=App.registerTools()=]] with tight JSON schemas and text-based results; MCP clients expect strings, not binary blobs.

* Testing & Verification
- Unit-level coverage should target config parsing and tool plumbing. Co-locate Jest specs under =src/__tests__/= or next to modules (e.g., [[file:src/app.ts::87][App helpers]]) and run them with =yarn test=, mocking [[file:src/lsp.ts::21][=LspClient=]] to avoid real processes.
- Integration checks rely on MCP clients: run =yarn mcp-cli:simple= after changes to schemas, LSP selection logic, or tool registration to confirm tool inventories.
- Before publishing Docker images or tags, execute =yarn build && yarn start --config dev/prod.config.json= to verify the transpiled binary boots without TypeScript helpers.
- No automated gating exists, so record manual verification commands in PR descriptions.

* Debugging & Failure Modes
- Pass =--verbose= to route JSON-RPC chatter to stderr. When MCP hosts suppress logs, rerun locally with identical arguments plus verbosity to capture traces.
- If an MCP client reports “tool missing,” call =lsp_info= to verify registration. Missing capabilities usually mean the LSP binary failed to spawn; double-check its availability inside the container.
- File errors often stem from URIs lacking =file://=. Use =file_contents_to_uri= for raw text buffers, or ensure workspace mounts expose the referenced files.
- Zombie LSP processes can linger if the host crashes; terminate them with =pkill -f "<command fragment>"= or PowerShell’s =Stop-Process=, or simply restart the container/CLI.
